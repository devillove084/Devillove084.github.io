<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>SGlang-KVCache 生命周期与PD分离传输分析 - Database builder</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Database builder"><meta name="msapplication-TileImage" content="/images/ironman.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Database builder"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本文目的是从 Prompt 到绘制到输出全链路数据结构、Tensor的生命周期，讲清楚“用户输入一句 prompt → KVCache 生成 → A 节点 → KVCache 传输 → B 节点恢复 → decode → detokenizer → 输出” ，在这条链路中涉及的核心数据结构、Tensor、转换&amp;#x2F;恢复点、生命周期与进程边界，尽可能详细地画出来。"><meta property="og:type" content="blog"><meta property="og:title" content="SGlang-KVCache 生命周期与PD分离传输分析"><meta property="og:url" content="https://devillove084.github.io/2026/01/12/SGlang-1/"><meta property="og:site_name" content="Database builder"><meta property="og:description" content="本文目的是从 Prompt 到绘制到输出全链路数据结构、Tensor的生命周期，讲清楚“用户输入一句 prompt → KVCache 生成 → A 节点 → KVCache 传输 → B 节点恢复 → decode → detokenizer → 输出” ，在这条链路中涉及的核心数据结构、Tensor、转换&amp;#x2F;恢复点、生命周期与进程边界，尽可能详细地画出来。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://devillove084.github.io/img/og_image.png"><meta property="article:published_time" content="2026-01-12T14:50:33.000Z"><meta property="article:modified_time" content="2026-01-12T07:21:50.270Z"><meta property="article:author" content="devillove084"><meta property="article:tag" content="sglang"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://devillove084.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://devillove084.github.io/2026/01/12/SGlang-1/"},"headline":"SGlang-KVCache 生命周期与PD分离传输分析","image":["https://devillove084.github.io/img/og_image.png"],"datePublished":"2026-01-12T14:50:33.000Z","dateModified":"2026-01-12T07:21:50.270Z","author":{"@type":"Person","name":"devillove084"},"publisher":{"@type":"Organization","name":"Database builder","logo":{"@type":"ImageObject","url":"https://devillove084.github.io/images/ironman.svg"}},"description":"本文目的是从 Prompt 到绘制到输出全链路数据结构、Tensor的生命周期，讲清楚“用户输入一句 prompt → KVCache 生成 → A 节点 → KVCache 传输 → B 节点恢复 → decode → detokenizer → 输出” ，在这条链路中涉及的核心数据结构、Tensor、转换&#x2F;恢复点、生命周期与进程边界，尽可能详细地画出来。"}</script><link rel="canonical" href="https://devillove084.github.io/2026/01/12/SGlang-1/"><link rel="icon" href="/images/ironman.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link data-pjax rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/ironman.svg" alt="Database builder" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Intro in github" href="https://github.com/devillove084"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2026-01-12T14:50:33.000Z" title="1/12/2026, 2:50:33 PM">2026-01-12</time>发表</span><span class="level-item"><time dateTime="2026-01-12T07:21:50.270Z" title="1/12/2026, 7:21:50 AM">2026-01-12</time>更新</span><span class="level-item">26 分钟读完 (大约3879个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">SGlang-KVCache 生命周期与PD分离传输分析</h1><div class="content"><p>本文目的是从 Prompt 到绘制到输出全链路数据结构、Tensor的生命周期，讲清楚<strong>“用户输入一句 prompt → KVCache 生成 → A 节点 → KVCache 传输 → B 节点恢复 → decode → detokenizer → 输出”</strong> ，在这条链路中<strong>涉及的核心数据结构、Tensor、转换&#x2F;恢复点、生命周期与进程边界</strong>，尽可能详细地画出来。</p>
<span id="more"></span>

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#0-%E6%80%BB%E8%A7%88%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E8%AE%BE%E5%A4%87%E8%BE%B9%E7%95%8C">0. 总览：进程&#x2F;线程&#x2F;设备边界</a></li>
<li><a href="#1-%E7%AB%AF%E5%88%B0%E7%AB%AF%E4%B8%BB%E9%93%BE%E8%B7%AF">1. 端到端主链路</a></li>
<li><a href="#2-prefilla-%E5%86%85%E9%83%A8">2. Prefill(A) 内部</a><ul>
<li><a href="#21-%E4%BB%8E-prompt-%E5%88%B0-token_idstokenizermanager">2.1 从 prompt 到 token_ids：TokenizerManager</a></li>
<li><a href="#22-prefixcacheradixcache">2.2 PrefixCache&#x2F;RadixCache</a></li>
<li><a href="#23-%E5%86%85%E5%AD%98%E6%B1%A0%E4%BA%8C%E7%BA%A7%E6%98%A0%E5%B0%84">2.3 内存池二级映射</a></li>
<li><a href="#24-prefill-forward">2.4 Prefill forward：</a></li>
</ul>
</li>
<li><a href="#3-ab-%E4%BC%A0%E8%BE%93">3. A→B 传输</a><ul>
<li><a href="#31-kv-%E6%95%B0%E6%8D%AE%E9%9D%A2">3.1 KV 数据面</a></li>
<li><a href="#32-kv-%E6%8E%A7%E5%88%B6%E9%9D%A2">3.2 KV 控制面</a></li>
<li><a href="#33-nixl%E4%B8%BA%E4%BE%8B%E4%BC%A0%E8%BE%93%E7%9A%84%E8%A1%8C%E4%B8%BA">3.3 NIXL为例，传输的行为</a></li>
</ul>
</li>
<li><a href="#4-decodeb-%E5%86%85%E9%83%A8">4. Decode(B) 内部</a><ul>
<li><a href="#41-bootstrap--pairingprefill-%E4%B8%8E-decode-%E9%85%8D%E5%AF%B9">4.1 Bootstrap &#x2F; Pairing（prefill 与 decode 配对）</a></li>
<li><a href="#42-preallocqueue">4.2 PreallocQueue</a></li>
<li><a href="#43-kv-%E6%81%A2%E5%A4%8D">4.3 KV 恢复</a></li>
<li><a href="#44-decode-loop">4.4 Decode loop</a></li>
</ul>
</li>
<li><a href="#5-detokenizer">5. Detokenizer</a></li>
<li><a href="#6-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">6. 生命周期</a></li>
<li><a href="#7-%E5%9B%9E%E6%94%BE%E8%A7%86%E8%A7%92%E4%B8%BA%E4%BA%86%E5%9C%A8-b-%E7%AB%AF%E7%BB%A7%E7%BB%AD%E7%94%9F%E6%88%90%E6%9C%80%E5%B0%91%E9%9C%80%E8%A6%81%E4%BB%80%E4%B9%88">7. 回放视角：为了在 B 端继续生成，最少需要什么</a><ul>
<li><a href="#71-replay-%E7%9A%84%E6%9C%80%E5%B0%8F%E9%97%AD%E5%8C%85">7.1 replay 的最小闭包</a></li>
<li><a href="#72-%E9%80%82%E9%85%8D-hicachekvstore-%E6%97%B6%E6%9C%80%E5%85%B3%E9%94%AE%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%BE%B9%E7%95%8C">7.2 适配 HiCache&#x2F;KVStore 时最关键的接口边界</a></li>
</ul>
</li>
<li><a href="#8-%E5%8F%AF%E9%80%89%E8%A7%82%E6%B5%8B%E7%82%B9">8. 可选观测点</a><ul>
<li><a href="#81-prefilla---before-send">8.1 Prefill(A) - before send</a></li>
<li><a href="#82-transfer-backend-nixl---submit">8.2 Transfer backend (NIXL) - submit</a></li>
<li><a href="#83-decodeb---after-restore">8.3 Decode(B) - after restore</a></li>
<li><a href="#84-decode-loop---per-step">8.4 Decode loop - per step</a></li>
</ul>
</li>
<li><a href="#%E9%99%84%E5%85%A8%E9%93%BE%E8%B7%AF-ascii-%E5%9B%BE">附：全链路 ASCII 图</a></li>
</ul>
<hr>
<h2 id="0-总览：进程-线程-设备边界"><a href="#0-总览：进程-线程-设备边界" class="headerlink" title="0. 总览：进程&#x2F;线程&#x2F;设备边界"></a>0. 总览：进程&#x2F;线程&#x2F;设备边界</h2><p>SGLang server（<code>python -m sglang.launch_server</code>）通常会启动多个子进程&#x2F;组件：</p>
<ul>
<li><strong>HTTP Server</strong>（FastAPI&#x2F;Uvicorn）：接收 <code>/generate</code> 等请求</li>
<li><strong>TokenizerManager &#x2F; TokenizerWorker</strong>：将 prompt → token_ids，并管理 disaggregation bootstrap（PD 相关）</li>
<li><strong>Scheduler 进程</strong>：核心调度循环，组 batch、调用 ModelRunner、管理 KV cache &#x2F; 内存池</li>
<li><strong>ModelWorker &#x2F; TPWorker</strong>：执行模型前向（prefill&#x2F;extend&#x2F;decode）</li>
<li><strong>Detokenizer 进程</strong>（或线程）：将输出 token_ids → 字符串（支持 streaming）</li>
</ul>
<p>PD 解耦时：</p>
<ul>
<li>**Prefill server (A)**：只做 prefill（prompt 部分前向），产出 KV</li>
<li>**Decode server (B)**：只做 decode（自回归生成），需要恢复 KV</li>
<li><strong>Router</strong>：把请求路由到 A&#x2F;B，并承接客户端的统一 HTTP 接口</li>
</ul>
<p>设备层面：</p>
<ul>
<li>L1：GPU KV cache pool（<code>MHATokenToKVPool/MLATokenToKVPool/...</code>）</li>
<li>L2：HostKVCache（pinned host memory）</li>
<li>L3：外部存储（Mooncake&#x2F;HF3FS&#x2F;File&#x2F;…）</li>
</ul>
<hr>
<h2 id="1-端到端主链路"><a href="#1-端到端主链路" class="headerlink" title="1. 端到端主链路"></a>1. 端到端主链路</h2><p>下面是一张“从用户到输出”的主链路 ASCII 总览图（<strong>进程边界</strong> + <strong>关键数据结构</strong>）：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Client (python/curl/web)</span><br><span class="line">    |<span class="string"></span></span><br><span class="line"><span class="string">    </span>|<span class="string">  HTTP POST /generate</span></span><br><span class="line"><span class="string">    </span>|<span class="string">  JSON: &#123; text, sampling_params, ... &#125;</span></span><br><span class="line"><span class="string">    v</span></span><br><span class="line"><span class="string">+--------------------------+</span></span><br><span class="line"><span class="string"></span>|<span class="string"> Router Process           </span>|</span><br><span class="line">|<span class="string">  - policy (random/...)   </span>|</span><br><span class="line">|<span class="string">  - PD pairing state      </span>|</span><br><span class="line">+--------------------------+</span><br><span class="line">    |<span class="string">                     </span>|</span><br><span class="line">    |<span class="string"> route(prompt)       </span>|<span class="string"> route(next token loop)</span></span><br><span class="line"><span class="string">    v                     v</span></span><br><span class="line"><span class="string">+---------------------+   +---------------------+</span></span><br><span class="line"><span class="string"></span>|<span class="string"> Prefill Server (A)  </span>|<span class="string">   </span>|<span class="string"> Decode Server (B)   </span>|</span><br><span class="line">|<span class="string"> disagg_mode=prefill </span>|<span class="string">   </span>|<span class="string"> disagg_mode=decode  </span>|</span><br><span class="line">+---------------------+   +---------------------+</span><br><span class="line">    |<span class="string">                           ^</span></span><br><span class="line"><span class="string">    </span>|<span class="string"> (1) tokenize + schedule   </span>|<span class="string"> (4) restore + decode loop</span></span><br><span class="line"><span class="string">    </span>|<span class="string"> (2) prefill forward       </span>|</span><br><span class="line">    |<span class="string"> (3) transfer KV + meta ---+</span></span><br><span class="line"><span class="string">    </span>|</span><br><span class="line">    v</span><br><span class="line">  (optional: A also returns some first tokens depending on implementation)</span><br><span class="line">    |<span class="string"></span></span><br><span class="line"><span class="string">    +-------------------------------&gt; Router merges/streams response</span></span><br><span class="line"><span class="string">                                      </span>|</span><br><span class="line">                                      v</span><br><span class="line">                                Client receives:</span><br><span class="line">                                - generated_text / stream chunks</span><br></pre></td></tr></table></figure>

<p>展开如下：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">                 (A) Prefill server                                    (B) Decode server</span><br><span class="line">+-----------------------------------------+                +-----------------------------------------+</span><br><span class="line">|<span class="string"> HTTP Server                              </span>|<span class="string">                </span>|<span class="string"> HTTP Server                              </span>|</span><br><span class="line">|<span class="string">  - parse JSON request                    </span>|<span class="string">                </span>|<span class="string">  - may receive from router internal path </span>|</span><br><span class="line">+-------------------+---------------------+                +-------------------+---------------------+</span><br><span class="line">                    |<span class="string">                                              </span>|</span><br><span class="line">                    v                                              v</span><br><span class="line">        +-----------------------+                      +-----------------------+</span><br><span class="line">        |<span class="string"> TokenizerManager      </span>|<span class="string">                      </span>|<span class="string"> TokenizerManager      </span>|</span><br><span class="line">        |<span class="string">  - prompt -&gt; token_ids</span>|<span class="string">                      </span>|<span class="string">  - may not tokenize    </span>|</span><br><span class="line">        |<span class="string">  - disagg bootstrap   </span>|<span class="string">                      </span>|<span class="string">  - bootstrap client    </span>|</span><br><span class="line">        +-----------+-----------+                      +-----------+-----------+</span><br><span class="line">                    |<span class="string">                                              </span>|</span><br><span class="line">                    v                                              v</span><br><span class="line">        +-----------------------+                      +-----------------------+</span><br><span class="line">        |<span class="string"> Scheduler Process     </span>|<span class="string">                      </span>|<span class="string"> Scheduler Process     </span>|</span><br><span class="line">        |<span class="string">  - ReqQueue           </span>|<span class="string">                      </span>|<span class="string">  - DecodeQueue        </span>|</span><br><span class="line">        |<span class="string">  - BatchBuilder       </span>|<span class="string">                      </span>|<span class="string">  - PreallocQueue      </span>|</span><br><span class="line">        |<span class="string">  - MemoryPool (L1/L2) </span>|<span class="string">                      </span>|<span class="string">  - MemoryPool (L1/L2) </span>|</span><br><span class="line">        |<span class="string">  - (Hi)RadixCache     </span>|<span class="string">                      </span>|<span class="string">  - (Hi)RadixCache opt </span>|</span><br><span class="line">        +-----------+-----------+                      +-----------+-----------+</span><br><span class="line">                    |<span class="string">                                              </span>|</span><br><span class="line">                    v                                              v</span><br><span class="line">        +-----------------------+                      +-----------------------+</span><br><span class="line">        |<span class="string"> ModelRunner/TPWorker  </span>|<span class="string">                      </span>|<span class="string"> ModelRunner/TPWorker  </span>|</span><br><span class="line">        |<span class="string">  forward_prefill      </span>|<span class="string">                      </span>|<span class="string">  forward_decode       </span>|</span><br><span class="line">        |<span class="string">  writes KV to L1 pool </span>|<span class="string">                      </span>|<span class="string">  reads KV from L1 pool</span>|</span><br><span class="line">        +-----------+-----------+                      +-----------+-----------+</span><br><span class="line">                    |<span class="string">                                              </span>|</span><br><span class="line">                    |<span class="string">         KV DATA + META (indices/mapping)      </span>|</span><br><span class="line">                    +--------------(NIXL/Mooncake/...)--------------+</span><br><span class="line">                                                   |<span class="string"></span></span><br><span class="line"><span class="string">                                                   v</span></span><br><span class="line"><span class="string">                                         +------------------+</span></span><br><span class="line"><span class="string">                                         </span>|<span class="string"> Detokenizer      </span>|</span><br><span class="line">                                         |<span class="string"> token_ids-&gt;text  </span>|</span><br><span class="line">                                         +------------------+</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-Prefill-A-内部"><a href="#2-Prefill-A-内部" class="headerlink" title="2. Prefill(A) 内部"></a>2. Prefill(A) 内部</h2><h3 id="2-1-从-prompt-到-token-ids：TokenizerManager"><a href="#2-1-从-prompt-到-token-ids：TokenizerManager" class="headerlink" title="2.1 从 prompt 到 token_ids：TokenizerManager"></a>2.1 从 prompt 到 token_ids：TokenizerManager</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">prompt <span class="punctuation">(</span>str<span class="punctuation">)</span></span><br><span class="line">  <span class="string">|</span></span><br><span class="line">  <span class="string">| tokenizer.encode(...)</span></span><br><span class="line">  v</span><br><span class="line">input_ids<span class="punctuation">:</span> List[int] / torch.Tensor[int32<span class="string">|int64] (CPU)</span></span><br><span class="line">  <span class="string">|</span></span><br><span class="line">  <span class="string">| (optional) add BOS/EOS/system prompt template</span></span><br><span class="line">  v</span><br><span class="line">Request<span class="punctuation">(</span>token_ids<span class="punctuation">,</span> sampling_params<span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><strong>核心结构（概念级）</strong>：</p>
<ul>
<li><code>Request</code><ul>
<li><code>rid</code> &#x2F; <code>request_id</code></li>
<li><code>prompt_text</code>（或不保留）</li>
<li><code>input_ids</code>（CPU tensor &#x2F; list）</li>
<li><code>sampling_params</code>（temperature&#x2F;top_p&#x2F;max_new_tokens&#x2F;…）</li>
<li><code>stage</code>（PD 时更明显：PREFILL_* &#x2F; DECODE_*）</li>
<li><code>req_pool_idx</code>（调度时分配）</li>
</ul>
</li>
</ul>
<h3 id="2-2-PrefixCache-RadixCache"><a href="#2-2-PrefixCache-RadixCache" class="headerlink" title="2.2 PrefixCache&#x2F;RadixCache"></a>2.2 PrefixCache&#x2F;RadixCache</h3><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">token_ids (full prompt)</span></span><br><span class="line"><span class="attribute">   |</span></span><br><span class="line"><span class="attribute">   | match_prefix(token_ids)</span></span><br><span class="line"><span class="attribute">   v</span></span><br><span class="line"><span class="attribute">MatchResult</span><span class="punctuation">:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">device_indices (L1 hit: token-&gt;KV slot indices)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">host_hit_length (L2 hit)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">last_device_node / last_host_node</span></span><br></pre></td></tr></table></figure>

<p>如果命中一段前缀：</p>
<ul>
<li>这段前缀对应的 KV 已存在（L1 或 L2&#x2F;L3 可回载）</li>
<li>prefill 需要计算的 token 数变少（只算未命中部分）</li>
<li>Request 会带上：<ul>
<li><code>cached_prefix_len</code></li>
<li><code>cached_device_indices</code>（用于直接复用 KV slots）</li>
</ul>
</li>
</ul>
<h3 id="2-3-内存池二级映射"><a href="#2-3-内存池二级映射" class="headerlink" title="2.3 内存池二级映射"></a>2.3 内存池二级映射</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(Request slot) req_pool_idx</span><br><span class="line">        |</span><br><span class="line">        | ReqToTokenPool.req_to_token<span class="comment">[req_pool_idx, pos]</span> = token_slot_idx</span><br><span class="line">        v</span><br><span class="line">(token_slot_idx)  &lt;---- allocated by TokenToKVPoolAllocator</span><br><span class="line">        |</span><br><span class="line">        | token_slot_idx indexes into per-layer KV buffers</span><br><span class="line">        v</span><br><span class="line">KVCache buffers (L1 GPU):</span><br><span class="line">  k_buffer<span class="comment">[layer]</span><span class="comment">[token_slot_idx, head, dim]</span></span><br><span class="line">  v_buffer<span class="comment">[layer]</span><span class="comment">[token_slot_idx, head, dim]</span></span><br></pre></td></tr></table></figure>

<p>更具体一点（以 MHA 为例，简化版）：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ReqToTokenPool.<span class="params">req_to_token :</span> int32 tensor on GPU (<span class="keyword">or</span> CPU depending impl)</span><br><span class="line">  <span class="attr">shape</span> <span class="operator">=</span> [max_running_requests, max_context_len]</span><br><span class="line">  <span class="attr">entry</span> <span class="operator">=</span> token_slot_idx</span><br><span class="line"></span><br><span class="line"><span class="params">TokenToKVPoolAllocator:</span></span><br><span class="line">  <span class="params">free_slots:</span> list <span class="symbol">/</span> bitmap <span class="symbol">/</span> queue</span><br><span class="line">  alloc(n_tokens, page_size) <span class="operator">-&gt;</span> token_slot_indices (possibly paged)</span><br><span class="line">  free(token_slot_indices)</span><br><span class="line"></span><br><span class="line"><span class="params">MHATokenToKVPool:</span></span><br><span class="line">  <span class="params">k_buffer:</span> List[Tensor] length <span class="operator">=</span> num_layers</span><br><span class="line">    <span class="params">each:</span> [kv_pool_size <span class="operator">+</span> page_size, n_kv_heads, head_dim] dtype<span class="operator">=</span>store_dtype device<span class="operator">=</span>cuda</span><br><span class="line">  <span class="params">v_buffer:</span> same</span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置 <code>--page_size 1</code> 时，分页粒度最细，便于观察 indices 和传输，但 overhead 更大。</p>
</blockquote>
<h3 id="2-4-Prefill-forward："><a href="#2-4-Prefill-forward：" class="headerlink" title="2.4 Prefill forward："></a>2.4 Prefill forward：</h3><p>prefill 时 Scheduler 会构造一个 batch：</p>
<ul>
<li><code>ForwardBatch</code><ul>
<li><code>input_ids</code>（GPU int32）</li>
<li><code>position_ids</code>（GPU int32）</li>
<li><code>req_pool_indices</code>（GPU int32，告诉 attention 哪些请求槽位参与）</li>
<li><code>seq_lens</code> &#x2F; <code>qo_indptr</code> &#x2F; <code>kv_indptr</code>（flashinfer&#x2F;triton backend 的 metadata）</li>
<li><code>kv_indices</code>（关键：本次新 token 写入 KV pool 的 slot indices）</li>
<li><code>index_slice</code>（关键：req_to_token 的切片范围，本次 extend 的 token span）</li>
</ul>
</li>
</ul>
<p>prefill 的关键副作用：</p>
<ul>
<li>对每一层 attention：<ul>
<li>计算得到本步 token 的 K,V</li>
<li>写入 <code>k_buffer[layer][kv_indices]</code> 和 <code>v_buffer[layer][kv_indices]</code></li>
</ul>
</li>
</ul>
<p>单次 batch 与新 token 写入的核心张量关系：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">new_tokens for request rid:</span><br><span class="line">  token positions: <span class="comment">[cached_prefix_len ... prompt_len-1]</span></span><br><span class="line">  |</span><br><span class="line">  | allocator alloc -&gt; kv_indices (GPU int32)</span><br><span class="line">  v</span><br><span class="line">kv_indices: <span class="comment">[n_new_tokens]</span>  (or paged <span class="comment">[n_pages, page_size]</span>)</span><br><span class="line">  |</span><br><span class="line">  | used as index into per-layer buffers</span><br><span class="line">  v</span><br><span class="line">for each layer l:</span><br><span class="line">  K_l_new: <span class="comment">[n_new_tokens, n_kv_heads, head_dim]</span>  (compute dtype)</span><br><span class="line">  V_l_new: <span class="comment">[n_new_tokens, n_kv_heads, head_dim]</span></span><br><span class="line">  |</span><br><span class="line">  | scatter/store into pool</span><br><span class="line">  v</span><br><span class="line">k_buffer<span class="comment">[l]</span><span class="comment">[kv_indices]</span> &lt;- K_l_new (store dtype)</span><br><span class="line">v_buffer<span class="comment">[l]</span><span class="comment">[kv_indices]</span> &lt;- V_l_new</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-A→B-传输"><a href="#3-A→B-传输" class="headerlink" title="3. A→B 传输"></a>3. A→B 传输</h2><p>PD 传输要解决的问题是：<strong>B 必须在它自己的 KV pool 中“拥有等价的 KV 状态”</strong>，才能从 prompt 末尾继续 decode，而不用重新 prefill。</p>
<p>因此传输内容分两大类：</p>
<h3 id="3-1-KV-数据面"><a href="#3-1-KV-数据面" class="headerlink" title="3.1 KV 数据面"></a>3.1 KV 数据面</h3><p>两种思路，不同实现可能不同：</p>
<ol>
<li><strong>按 token slot 直接传</strong>（最直观）：把 A 的 <code>k_buffer/layer</code> 中 <code>kv_indices</code> 对应的数据拷到 B 的 pool 对应 slots</li>
<li><strong>按 page 批量传</strong>（更高效）：如果 allocator 是 page&#x2F;Block，连续块更容易跑满带宽</li>
</ol>
<p>抽象为：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">KVPayload</span>:</span><br><span class="line">  for layer <span class="keyword">in</span> [<span class="number">0.</span>.<span class="type">L</span><span class="number">-1</span>]:</span><br><span class="line">    <span class="type">K</span>: bytes <span class="keyword">of</span> shape [n_transfer_tokens, n_kv_heads, head_dim] (store d<span class="keyword">type</span>)</span><br><span class="line">    <span class="type">V</span>: bytes <span class="keyword">of</span> shape [n_transfer_tokens, n_kv_heads, head_dim] (store d<span class="keyword">type</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-KV-控制面"><a href="#3-2-KV-控制面" class="headerlink" title="3.2 KV 控制面"></a>3.2 KV 控制面</h3><p><strong>B 必须知道这些 KV 对应“哪个请求、哪个 token range、写到哪里、用什么布局解释”</strong>。</p>
<p>最少需要：</p>
<ul>
<li><code>rid</code> &#x2F; <code>request_id</code></li>
<li><code>prompt_len</code>（或至少“已存在的上下文长度”）</li>
<li><code>kv_cache_dtype</code> &#x2F; <code>store_dtype</code></li>
<li><code>attention_arch</code>（MHA&#x2F;MLA&#x2F;NSA…）与其参数（head_dim、kv_heads、layer_num 等）</li>
<li><code>page_size</code>（如果 paged）</li>
<li><code>kv_indices</code>（A 侧 token→slot 映射，或它的等价压缩表示）</li>
<li><code>index_slice</code> &#x2F; <code>token_range</code>（本次 prefill&#x2F;extend 的 span）</li>
<li>（可选）<code>cached_prefix_len</code> 与 prefix cache 命中信息（若 B 需要知道哪些 token 不需要再传）</li>
</ul>
<p>大概是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">KVTransferMeta (example):</span><br><span class="line">&#123;</span><br><span class="line">  rid: u64,</span><br><span class="line">  model_id: string,</span><br><span class="line">  arch: <span class="string">&quot;MHA&quot;</span> | <span class="string">&quot;MLA&quot;</span> | ...,</span><br><span class="line">  layer_num: <span class="built_in">int</span>,</span><br><span class="line">  kv_heads: <span class="built_in">int</span>,</span><br><span class="line">  head_dim: <span class="built_in">int</span>,</span><br><span class="line">  v_head_dim: <span class="built_in">int</span>,</span><br><span class="line">  store_dtype: <span class="string">&quot;bf16&quot;</span> | <span class="string">&quot;fp16&quot;</span> | <span class="string">&quot;uint8(fp8)&quot;</span> | ...,</span><br><span class="line">  page_size: <span class="built_in">int</span>,</span><br><span class="line">  prompt_len: <span class="built_in">int</span>,</span><br><span class="line">  cached_prefix_len: <span class="built_in">int</span>,</span><br><span class="line">  token_range: [start_pos, end_pos),</span><br><span class="line">  kv_indices: int32[...] <span class="keyword">or</span> pages[...]  // A-&gt;B mapping handle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-NIXL为例，传输的行为"><a href="#3-3-NIXL为例，传输的行为" class="headerlink" title="3.3 NIXL为例，传输的行为"></a>3.3 NIXL为例，传输的行为</h3><p>把 PD 传输抽象成 “提交一组 buffer + 事件同步”：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A side:</span><br><span class="line">  buffers_to_send = [</span><br><span class="line">    meta_bytes (CPU <span class="keyword">or</span> GPU),</span><br><span class="line">    K_layer0_chunk (GPU),</span><br><span class="line">    V_layer0_chunk (GPU),</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">  nixl.submit<span class="function"><span class="params">(send, buffers_to_send)</span>  -&gt;</span> completion event</span><br><span class="line"></span><br><span class="line">B side:</span><br><span class="line">  prealloc slots <span class="keyword">in</span> KV pool</span><br><span class="line">  nixl.submit<span class="function"><span class="params">(recv, buffers_to_recv)</span>  -&gt;</span> completion event</span><br><span class="line">  <span class="literal">on</span> complete: <span class="string">&quot;restore mapping&quot;</span> so decode <span class="keyword">loop</span> can see correct req_to_token / kv_indices</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-Decode-B-内部"><a href="#4-Decode-B-内部" class="headerlink" title="4. Decode(B) 内部"></a>4. Decode(B) 内部</h2><p>Decode server 的难点是：它需要把“传来的 KV”变成自己内部的“可 decode 状态”。Bootstrap&#x2F;Prealloc → KV 恢复(挂载) → Decode loop → Logits → Sample</p>
<h3 id="4-1-Bootstrap-Pairing（prefill-与-decode-配对）"><a href="#4-1-Bootstrap-Pairing（prefill-与-decode-配对）" class="headerlink" title="4.1 Bootstrap &#x2F; Pairing（prefill 与 decode 配对）"></a>4.1 Bootstrap &#x2F; Pairing（prefill 与 decode 配对）</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prefill<span class="built_in"> server </span>registers <span class="keyword">to</span> bootstrap<span class="built_in"> service</span></span><br><span class="line"><span class="built_in"></span>decode<span class="built_in"> server </span>registers <span class="keyword">to</span> bootstrap<span class="built_in"> service</span></span><br><span class="line"><span class="built_in"></span>bootstrap matches them (room/pair_key)</span><br><span class="line">-&gt; returns transport endpoints/credentials <span class="keyword">for</span> direct transfer</span><br></pre></td></tr></table></figure>

<h3 id="4-2-PreallocQueue"><a href="#4-2-PreallocQueue" class="headerlink" title="4.2 PreallocQueue"></a>4.2 PreallocQueue</h3><p>在收 KV 前先把Slot和结构准备好，decode 一般会在接收前：</p>
<ul>
<li>分配 <code>req_pool_idx</code>（请求槽位）</li>
<li>分配 token slot indices（按 prompt_len 或 token_range）</li>
<li>准备好 <code>req_to_token</code> 表中的切片空间</li>
</ul>
<p>这样 KV 一到，就能直接 copy&#x2F;scatter 到目标位置，这样可以将malloc和RDMA&#x2F;CUDA注册和数据拷贝overlap。</p>
<h3 id="4-3-KV-恢复"><a href="#4-3-KV-恢复" class="headerlink" title="4.3 KV 恢复"></a>4.3 KV 恢复</h3><p>重建 token→slot 映射和重填 KV pool，恢复过程抽象如下：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">recv<span class="punctuation">(</span>K<span class="punctuation">,</span>V payload <span class="punctuation">+</span> meta<span class="punctuation">)</span></span><br><span class="line">   <span class="string">|</span></span><br><span class="line">   <span class="string">| parse meta -&gt; knows prompt_len, token_range, page_size, ...</span></span><br><span class="line">   <span class="string">|</span></span><br><span class="line">   <span class="string">| allocate target slots in B&#x27;s KV pool:</span></span><br><span class="line">   <span class="string">|   b_kv_indices = allocator.alloc(n_tokens)</span></span><br><span class="line">   <span class="string">|</span></span><br><span class="line">   <span class="string">| receive/copy KV bytes into:</span></span><br><span class="line">   <span class="string">|   b_k_buffer[layer][b_kv_indices]  &lt;- payload.K[layer]</span></span><br><span class="line">   <span class="string">|   b_v_buffer[layer][b_kv_indices]  &lt;- payload.V[layer]</span></span><br><span class="line">   <span class="string">|</span></span><br><span class="line">   <span class="string">| rebuild ReqToTokenPool mapping:</span></span><br><span class="line">   <span class="string">|   req_to_token[req_pool_idx, token_range] = b_kv_indices</span></span><br><span class="line">   v</span><br><span class="line">Request now becomes <span class="string">&quot;decode-ready&quot;</span></span><br></pre></td></tr></table></figure>

<p>ASCII 展开：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">B side restore</span></span><br><span class="line"><span class="section">=============</span></span><br><span class="line">meta.token<span class="emphasis">_range = [0, prompt_len)   # 把整个 prompt 的 KV 都恢复</span></span><br><span class="line"><span class="emphasis">meta.kv_indices  = [a_slot0, a_slot1, ...]   # A 的 slot 编号（可能仅用于 debug/校验）</span></span><br><span class="line"><span class="emphasis">                     |</span></span><br><span class="line"><span class="emphasis">                     | B 不一定复用 A 的 slot 编号；通常重新 alloc 自己的 slots</span></span><br><span class="line"><span class="emphasis">                     v</span></span><br><span class="line"><span class="emphasis">b_kv_indices = allocator_B.alloc(prompt_</span>len)</span><br><span class="line"></span><br><span class="line">for each layer l:</span><br><span class="line"><span class="code">  k_buffer_B[l][b_kv_indices] &lt;- recv K bytes</span></span><br><span class="line"><span class="code">  v_buffer_B[l][b_kv_indices] &lt;- recv V bytes</span></span><br><span class="line"></span><br><span class="line">ReqToTokenPool_B.req_to_token[req_pool_idx, 0:prompt_len] = b_kv_indices</span><br></pre></td></tr></table></figure>

<h3 id="4-4-Decode-loop"><a href="#4-4-Decode-loop" class="headerlink" title="4.4 Decode loop"></a>4.4 Decode loop</h3><p>进入 decode loop 后，每一步大概是：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(last_token_id, position_id, req_pool_idx)</span><br><span class="line">    |</span><br><span class="line">    | attention reads KV <span class="keyword">from</span> pool via req_to_token mapping</span><br><span class="line">    v</span><br><span class="line">logits -&gt; sampling -&gt; next_token_id</span><br><span class="line">    |</span><br><span class="line">    +--&gt; append token_id <span class="keyword">to</span> request output buffer</span><br><span class="line">    |</span><br><span class="line">    +--&gt; write <span class="keyword">new</span> token KV into KV pool (extend)</span><br></pre></td></tr></table></figure>

<p>对应的数据结构：</p>
<ul>
<li><code>ForwardBatch</code>（decode）<ul>
<li><code>input_ids</code>：通常只有 last token（或少数 tokens）</li>
<li><code>req_pool_indices</code></li>
<li><code>kv_indices</code>：本次新生成 token 的 slots（allocator 新分配）</li>
<li>其余 attention metadata（indptr 等）</li>
</ul>
</li>
</ul>
<p><strong>重要：</strong> decode 的 KV 写入和 prefill 一样，只是每步 token 很少。</p>
<hr>
<h2 id="5-Detokenizer"><a href="#5-Detokenizer" class="headerlink" title="5. Detokenizer"></a>5. Detokenizer</h2><p>Detokenizer 的核心任务是把模型输出 token ids 转为字符串，并处理 streaming（增量输出）。</p>
<p>简化流程：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Scheduler <span class="symbol">/</span> ModelWorker <span class="params">produces:</span></span><br><span class="line">  <span class="params">out_token_ids:</span> List[int]  (per request)</span><br><span class="line">  <span class="operator">+</span> maybe logprobs, finish_reason, usage</span><br><span class="line">        |</span><br><span class="line">        | send to detokenizer process via queue<span class="symbol">/pipe</span></span><br><span class="line">        v</span><br><span class="line"><span class="params">Detokenizer:</span></span><br><span class="line">  tokenizer.decode(incremental_ids, skip_special_tokens<span class="operator">=</span>...)</span><br><span class="line">        |</span><br><span class="line">        v</span><br><span class="line">text delta <span class="symbol">/</span> full text</span><br><span class="line">        |</span><br><span class="line">        v</span><br><span class="line">HTTP <span class="params">response:</span></span><br><span class="line">  <span class="operator">-</span> <span class="params">non-stream:</span> &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot;...&quot;</span>&#125;</span><br><span class="line">  <span class="operator">-</span> <span class="params">stream:</span> chunks (SSE<span class="symbol">/websocket/HTTP</span> chunked)</span><br></pre></td></tr></table></figure>

<p>A→B replay,detokenizer 侧最关键的观测点是：</p>
<ul>
<li>B 端产生的 token_ids 序列是否与 monolithic 一致（deterministic inference）</li>
<li>streaming 时的 “delta” 是否一致（有时会受分块、缓存影响）</li>
</ul>
<hr>
<h2 id="6-生命周期"><a href="#6-生命周期" class="headerlink" title="6. 生命周期"></a>6. 生命周期</h2><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">time ───────────────────────────────────────────────────────────────────────────────&gt;</span><br><span class="line"></span><br><span class="line">Client JSON req</span><br><span class="line">  |</span><br><span class="line">Router receives req (owns request envelope)</span><br><span class="line">  |</span><br><span class="line">  |  (A) prefill stage</span><br><span class="line">  v</span><br><span class="line"><span class="symbol">A:</span> TokenizerManager creates Request(rid, input_ids, sampling_params)   [lifetime: <span class="keyword">until</span> prefill done]</span><br><span class="line">  |</span><br><span class="line"><span class="symbol">A:</span> Scheduler alloc req_pool_idx_A                                    [<span class="keyword">until</span> request finished <span class="built_in">or</span> handed <span class="keyword">off</span>]</span><br><span class="line">  |</span><br><span class="line"><span class="symbol">A:</span> ReqToTokenPool slice reserved                                     [<span class="keyword">until</span> request finished <span class="built_in">or</span> cache pinned]</span><br><span class="line">  |</span><br><span class="line"><span class="symbol">A:</span> TokenToKVAllocator alloc kv_indices <span class="keyword">for</span> prompt tokens             [<span class="keyword">until</span> freed <span class="built_in">or</span> cached <span class="keyword">in</span> radix]</span><br><span class="line">  |</span><br><span class="line"><span class="symbol">A:</span> ModelRunner prefill forward writes K/V <span class="keyword">into</span> KV pool               [KV pool <span class="keyword">global</span> lifetime; slots per req lifetime]</span><br><span class="line">  |</span><br><span class="line"><span class="symbol">A:</span> (<span class="keyword">optional</span>) RadixCache inserts nodes / inc lock_ref                [<span class="keyword">until</span> eviction/refcount drop]</span><br><span class="line">  |</span><br><span class="line"><span class="symbol">A:</span> Disagg Transfer packages (meta + KV bytes)                        [ephemeral; per transfer]</span><br><span class="line">  |</span><br><span class="line"><span class="symbol">A:</span> Transfer completes → A may free its per-request slots <span class="built_in">OR</span> keep cached prefix</span><br><span class="line">  |</span><br><span class="line">  +-----------------------------------------------------------------------------------+</span><br><span class="line">                                                                                      |</span><br><span class="line">                                                                                      v</span><br><span class="line"><span class="symbol">B:</span> PreallocQueue reserves req_pool_idx_B + kv slots                                  [<span class="keyword">until</span> request finished]</span><br><span class="line"><span class="symbol">B:</span> Receive KV bytes <span class="keyword">into</span> B<span class="comment">&#x27;s KV pool slots                                            [KV pool global; slots per req]</span></span><br><span class="line"><span class="symbol">B:</span> Rebuild ReqToTokenPool mapping <span class="keyword">for</span> rid                                             [<span class="keyword">until</span> finished]</span><br><span class="line"><span class="symbol">B:</span> Decode <span class="keyword">loop</span> generates tokens; <span class="keyword">each</span> token alloc <span class="built_in">new</span> kv slot                         [<span class="keyword">until</span> finished/cached]</span><br><span class="line"><span class="symbol">B:</span> Token ids pushed <span class="keyword">to</span> detokenizer queue                                              [ephemeral buffer]</span><br><span class="line"><span class="symbol">B:</span> Detokenizer builds output <span class="keyword">text</span>                                                     [<span class="keyword">until</span> response complete]</span><br><span class="line"><span class="symbol">B:</span> <span class="keyword">When</span> finished: free req_pool_idx_B slots (unless cached)                           [free list]</span><br></pre></td></tr></table></figure>

<p>一个很重要的“拥有权&#x2F;一致性”点：</p>
<ul>
<li><strong>KV pool 是全局缓冲区（per instance）</strong>，请求只是占用其中的一些 token slots</li>
<li><strong>ReqToTokenPool 是 per instance 的请求索引表</strong>，把请求上下文位置映射到 token slots</li>
<li>Radix&#x2F;HiCache 会让某些 token slots 的生命周期<strong>超出请求本身</strong>（作为缓存被共享&#x2F;被备份）</li>
</ul>
<hr>
<h2 id="7-回放视角：为了在-B-端继续生成，最少需要什么"><a href="#7-回放视角：为了在-B-端继续生成，最少需要什么" class="headerlink" title="7. 回放视角：为了在 B 端继续生成，最少需要什么"></a>7. 回放视角：为了在 B 端继续生成，最少需要什么</h2><p>站在自定义 KVStore，要实现 A→B 恢复 + replay角度：</p>
<h3 id="7-1-replay-的最小闭包"><a href="#7-1-replay-的最小闭包" class="headerlink" title="7.1 replay 的最小闭包"></a>7.1 replay 的最小闭包</h3><p>要在 B 端继续 decode，至少要恢复：</p>
<ol>
<li><strong>模型参数一致</strong>（同 model_path &#x2F; same weights version）</li>
<li><strong>tokenizer&#x2F;模板一致</strong>（prompt → token_ids 必须一致；否则 KV 对不上）</li>
<li><strong>上下文 token_ids 序列</strong>（至少长度&#x2F;position 对齐）</li>
<li><strong>KV 内容</strong>（对每层 K&#x2F;V，覆盖 [0:prompt_len) 的上下文）</li>
<li><strong>token→slot 映射</strong>（B 的 req_to_token[req_pool_idx, 0:prompt_len]）</li>
<li><strong>生成状态</strong>（sampling_params、random_seed、是否 deterministic）</li>
</ol>
<p>把“恢复态”定义成一个可序列化的 snapshot：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReplaySnapshot &#123;</span><br><span class="line">  rid,</span><br><span class="line">  model_id,</span><br><span class="line">  prompt_token_ids,</span><br><span class="line">  prompt_len,</span><br><span class="line">  kv_store_ref / kv_bytes,</span><br><span class="line">  kv_layout_meta,</span><br><span class="line">  req_to_token_mapping (<span class="keyword">implicit</span> or explicit),</span><br><span class="line">  sampling_state (seed, temperature, top_p, ...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-适配-HiCache-KVStore-时最关键的接口边界"><a href="#7-2-适配-HiCache-KVStore-时最关键的接口边界" class="headerlink" title="7.2 适配 HiCache&#x2F;KVStore 时最关键的接口边界"></a>7.2 适配 HiCache&#x2F;KVStore 时最关键的接口边界</h3><p>适配HiCache 接口和自定义的 KVStore，一般的：</p>
<ul>
<li><strong>把某段 token_range 的 KV 写入&#x2F;读出到外部 store</strong></li>
<li><strong>把外部 KV 恢复到某个 server instance 的 KV pool + 映射结构</strong></li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">store_put</span><span class="params">(key=(model, layer, page/token_range, ...)</span></span>, value=KV bytes, meta=layout)</span><br><span class="line"><span class="function"><span class="title">store_get</span><span class="params">(key=..., ...)</span></span> -&gt; KV bytes + meta</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">restore_to_kvpool</span><span class="params">(meta, kv_bytes)</span></span> -&gt; b_kv_indices + write req_to_token</span><br><span class="line"><span class="function"><span class="title">extract_from_kvpool</span><span class="params">(req_pool_idx, token_range)</span></span> -&gt; kv_bytes + meta</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-可选观测点"><a href="#8-可选观测点" class="headerlink" title="8. 可选观测点"></a>8. 可选观测点</h2><h3 id="8-1-Prefill-A-before-send"><a href="#8-1-Prefill-A-before-send" class="headerlink" title="8.1 Prefill(A) - before send"></a>8.1 Prefill(A) - before send</h3><ul>
<li><code>rid</code></li>
<li><code>prompt_len</code>, <code>cached_prefix_len</code></li>
<li><code>req_pool_idx_A</code></li>
<li><code>index_slice</code> &#x2F; <code>token_range</code></li>
<li><code>kv_indices</code>（shape&#x2F;dtype + 前 16 个 + min&#x2F;max）</li>
<li><code>KV pool layout meta</code>（layer_num, head_dim, kv_heads, dtype, page_size）</li>
<li><code>payload_total_bytes</code>（按 layer 计算或从 backend 获取）</li>
<li>（可选）<code>k_hash/v_hash</code>（小窗口 hash）</li>
</ul>
<h3 id="8-2-Transfer-backend-NIXL-submit"><a href="#8-2-Transfer-backend-NIXL-submit" class="headerlink" title="8.2 Transfer backend (NIXL) - submit"></a>8.2 Transfer backend (NIXL) - submit</h3><ul>
<li><code>rid</code></li>
<li><code>num_bufs</code>, <code>total_bytes</code></li>
<li>每个 buffer 的：<ul>
<li><code>device</code> (cuda&#x2F;cpu)</li>
<li><code>nbytes</code></li>
<li><code>dtype</code>（如果是 tensor）</li>
</ul>
</li>
<li><code>completion latency</code>（提交→完成）</li>
</ul>
<h3 id="8-3-Decode-B-after-restore"><a href="#8-3-Decode-B-after-restore" class="headerlink" title="8.3 Decode(B) - after restore"></a>8.3 Decode(B) - after restore</h3><ul>
<li><code>rid</code></li>
<li><code>req_pool_idx_B</code></li>
<li><code>prompt_len</code></li>
<li><code>b_kv_indices</code>（或恢复后写进 req_to_token 的 slice）</li>
<li><code>req_to_token[req_pool_idx_B, 0:prompt_len]</code>（desc + head）</li>
<li><code>k_hash/v_hash</code>（与 A 对比）</li>
</ul>
<h3 id="8-4-Decode-loop-per-step"><a href="#8-4-Decode-loop-per-step" class="headerlink" title="8.4 Decode loop - per step"></a>8.4 Decode loop - per step</h3><ul>
<li><code>step i</code></li>
<li><code>last_token_id</code></li>
<li><code>next_token_id</code></li>
<li><code>kv_indices_new</code>（本步新增 token）</li>
<li>结束原因（eos&#x2F;length&#x2F;…）</li>
</ul>
<hr>
<h2 id="附：全链路-ASCII-图"><a href="#附：全链路-ASCII-图" class="headerlink" title="附：全链路 ASCII 图"></a>附：全链路 ASCII 图</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">(1) Client -&gt; Router</span></span><br><span class="line"><span class="section">===================</span></span><br><span class="line">POST /generate</span><br><span class="line">payload = &#123;</span><br><span class="line"><span class="code">  &quot;text&quot;: prompt:str,</span></span><br><span class="line"><span class="code">  &quot;sampling_params&quot;: &#123;...&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">(2) Router -&gt; Prefill(A)</span></span><br><span class="line"><span class="section">========================</span></span><br><span class="line">Router selects (prefill_url, decode_url)</span><br><span class="line">Router forwards request envelope to A (or calls A internal API)</span><br><span class="line"></span><br><span class="line"><span class="section">(3) Prefill(A) tokenize + schedule</span></span><br><span class="line"><span class="section">==================================</span></span><br><span class="line">prompt:str</span><br><span class="line"><span class="code">  -&gt; token_ids: List[int] / Tensor[int32]  (CPU)</span></span><br><span class="line"><span class="code">  -&gt; Request(rid, token_ids, sampling_params, stage=PREFILL_*)</span></span><br><span class="line"><span class="code">  -&gt; Scheduler:</span></span><br><span class="line"><span class="code">       req_pool_idx_A = ReqToTokenPool.alloc(1)</span></span><br><span class="line"><span class="code">       (Radix match) -&gt; cached_prefix_len + cached_device_indices</span></span><br><span class="line"><span class="code">       n_new = prompt_len - cached_prefix_len</span></span><br><span class="line"><span class="code">       kv_indices_A = TokenToKVPoolAllocator.alloc(n_new, page_size)</span></span><br><span class="line"><span class="code">       ReqToTokenPool.req_to_token[req_pool_idx_A, cached_prefix_len:prompt_len] = kv_indices_A</span></span><br><span class="line"></span><br><span class="line"><span class="section">(4) Prefill(A) forward_prefill writes KV</span></span><br><span class="line"><span class="section">========================================</span></span><br><span class="line">ForwardBatch.prefill:</span><br><span class="line"><span class="code">  input_ids      : GPU int32  [n_tokens_total or chunk]</span></span><br><span class="line"><span class="code">  position_ids   : GPU int32</span></span><br><span class="line"><span class="code">  req_pool_indices: GPU int32 [batch_size]</span></span><br><span class="line"><span class="code">  kv_indices     : GPU int32 [n_new_tokens]</span></span><br><span class="line"><span class="code">  index_slice    : (req_pool_idx_A, slice(cached_prefix_len, prompt_len))</span></span><br><span class="line"><span class="code">  attn meta      : qo_indptr / kv_indptr / ...</span></span><br><span class="line">ModelRunner.forward<span class="emphasis">_prefill():</span></span><br><span class="line"><span class="emphasis">  for layer l:</span></span><br><span class="line"><span class="emphasis">    K_l_new, V_l_new computed</span></span><br><span class="line"><span class="emphasis">    k_buffer_A[l][kv_indices_A] &lt;- K_l_new</span></span><br><span class="line"><span class="emphasis">    v_buffer_A[l][kv_indices_A] &lt;- V_l_</span>new</span><br><span class="line"></span><br><span class="line"><span class="section">(5) Prefill(A) -&gt; Transfer (KV + meta)</span></span><br><span class="line"><span class="section">======================================</span></span><br><span class="line">KVTransferMeta:</span><br><span class="line"><span class="code">  rid, prompt_len, cached_prefix_len,</span></span><br><span class="line"><span class="code">  layer_num, kv_heads, head_dim, dtype, page_size,</span></span><br><span class="line"><span class="code">  token_range, (maybe) kv_indices_A (for debug)</span></span><br><span class="line">KVPayload:</span><br><span class="line"><span class="code">  for l in layers:</span></span><br><span class="line"><span class="code">    K bytes for token_range</span></span><br><span class="line"><span class="code">    V bytes for token_range</span></span><br><span class="line"></span><br><span class="line"><span class="section">(6) Decode(B) prealloc + receive + restore mapping</span></span><br><span class="line"><span class="section">==================================================</span></span><br><span class="line">DecodePreallocQueue:</span><br><span class="line"><span class="code">  req_pool_idx_B = ReqToTokenPool.alloc(1)</span></span><br><span class="line"><span class="code">  b_kv_indices = TokenToKVPoolAllocator.alloc(prompt_len)</span></span><br><span class="line">Receive payload:</span><br><span class="line"><span class="code">  for layer l:</span></span><br><span class="line"><span class="code">    k_buffer_B[l][b_kv_indices] &lt;- recv K bytes</span></span><br><span class="line"><span class="code">    v_buffer_B[l][b_kv_indices] &lt;- recv V bytes</span></span><br><span class="line">Restore:</span><br><span class="line"><span class="code">  ReqToTokenPool.req_to_token[req_pool_idx_B, 0:prompt_len] = b_kv_indices</span></span><br><span class="line"><span class="code">  Request.stage = DECODE_READY</span></span><br><span class="line"></span><br><span class="line"><span class="section">(7) Decode loop</span></span><br><span class="line"><span class="section">===============</span></span><br><span class="line">for step in [0..max<span class="emphasis">_new_tokens):</span></span><br><span class="line"><span class="emphasis">  ForwardBatch.decode:</span></span><br><span class="line"><span class="emphasis">    input_ids (last token) : GPU int32 [bs]</span></span><br><span class="line"><span class="emphasis">    position_ids           : GPU int32</span></span><br><span class="line"><span class="emphasis">    req_pool_indices       : GPU int32</span></span><br><span class="line"><span class="emphasis">    kv_indices_new         : GPU int32 [bs]   (alloc 1 slot / req)</span></span><br><span class="line"><span class="emphasis">  ModelRunner.forward_decode():</span></span><br><span class="line"><span class="emphasis">    reads KV via req_to_token mapping</span></span><br><span class="line"><span class="emphasis">    outputs logits</span></span><br><span class="line"><span class="emphasis">  Sampler():</span></span><br><span class="line"><span class="emphasis">    next_token_id</span></span><br><span class="line"><span class="emphasis">  write KV for new token:</span></span><br><span class="line"><span class="emphasis">    k_buffer_B[l][kv_indices_new] &lt;- K_new</span></span><br><span class="line"><span class="emphasis">    v_buffer_B[l][kv_indices_new] &lt;- V_new</span></span><br><span class="line"><span class="emphasis">  append token_</span>id to output stream</span><br><span class="line"></span><br><span class="line"><span class="section">(8) Detokenizer + HTTP response</span></span><br><span class="line"><span class="section">===============================</span></span><br><span class="line">token_ids stream -&gt; detokenizer queue</span><br><span class="line">detokenizer.decode(...) -&gt; text delta</span><br><span class="line">router returns:</span><br><span class="line"><span class="code">  &#123;&quot;text&quot;: &quot;...&quot;&#125; or streaming chunks</span></span><br></pre></td></tr></table></figure></div><div class="article-licensing box"><div class="licensing-title"><p>SGlang-KVCache 生命周期与PD分离传输分析</p><p><a href="https://devillove084.github.io/2026/01/12/SGlang-1/">https://devillove084.github.io/2026/01/12/SGlang-1/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>devillove084</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2026-01-12</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2026-01-12</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/sglang/">sglang</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=65f6a62f301e18001359b8f1&amp;product=inline-share-buttons&amp;source=platform" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/images/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/images/wechat.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2026/01/11/PG-1/"><span class="level-item">PostgreSQL 社区风格开发总结</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card" id="comments"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/valine/1.4.16/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "qoeAcymwpY5SQb4ABehlBKLq-gzGzoHsz",
            appKey: "Ei0kV5tVeRpYCcAnan39Oqpx",
            
            avatar: "mm",
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            visitor: false,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: false,
            requiredFields: [],
        });</script></div></div></div><!--!--><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/ironman.svg" alt="Database builder" height="28"></a><p class="is-size-7"><span>&copy; 2026 devillove084</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Intro in github" href="https://github.com/devillove084"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.cloudflare.com/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/katex.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/katex.min.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/contrib/auto-render.min.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><script src="https://cdn.jsdelivr.net/npm/mermaid@11.5.0/dist/mermaid.min.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>